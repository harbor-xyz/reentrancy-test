"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnvilServer = void 0;
const child_process_1 = require("child_process");
const debug_1 = __importDefault(require("debug"));
const easy_foundryup_1 = require("@foundry-rs/easy-foundryup");
const log = (0, debug_1.default)("hardhat::plugin::anvil::spawn");
class AnvilServer {
    constructor(options, anvil) {
        this._options = options;
        this._anvil = anvil;
    }
    static async launch(options, inherit = false) {
        var _a;
        log("Launching anvil");
        let anvil;
        if (options.launch) {
            const anvilPath = (_a = options.path) !== null && _a !== void 0 ? _a : (await (0, easy_foundryup_1.getAnvilCommand)());
            const args = [];
            if (options.host) {
                args.push("--host", options.host);
            }
            if (options.port) {
                args.push("--port", options.port);
            }
            if (options.totalAccounts) {
                args.push("--accounts", options.totalAccounts);
            }
            if (options.mnemonic) {
                args.push("--mnemonic", options.mnemonic);
            }
            if (options.defaultBalanceEther) {
                args.push("--balance", options.defaultBalanceEther);
            }
            if (options.hdPath) {
                args.push("--derivation-path", options.hdPath);
            }
            if (options.silent) {
                args.push("--silent", options.silent);
            }
            if (options.blockTime) {
                args.push("--block-time", options.blockTime);
            }
            if (options.gasLimit) {
                args.push("--gas-limit", options.gasLimit);
            }
            if (options.gasPrice) {
                if (options.gasPrice !== "auto") {
                    args.push("--gas-price", options.gasPrice);
                }
            }
            if (options.chainId) {
                args.push("--chain-id", options.chainId);
            }
            if (options.forkurl) {
                args.push("--fork-url", options.forkurl);
                if (options.forkBlockNumber) {
                    args.push("--fork-block-number", options.forkBlockNumber);
                }
            }
            if (options.noStorageCaching) {
                args.push("--no-storage-caching");
            }
            if (options.hardfork) {
                if (options.hardfork !== "arrowGlacier") {
                    args.push("--hardfork", options.hardfork);
                }
            }
            const opts = inherit ? { stdio: "inherit" } : {};
            anvil = (0, child_process_1.spawn)(anvilPath, args, opts);
            anvil.on("close", (code) => {
                log(`anvil child process exited with code ${code}`);
            });
            process.on("exit", function () {
                anvil.kill();
            });
            if (!inherit) {
                let serverReady = false;
                anvil.stdout.on("data", (data) => {
                    const output = data.toString();
                    if (output.includes("Listening")) {
                        serverReady = true;
                    }
                    log(`${data}`);
                });
                anvil.stderr.on("data", (data) => {
                    log(`${data}`);
                });
                // wait until server ready
                const retries = 30; // 3secs
                for (let i = 0; i < retries; i++) {
                    if (serverReady) {
                        log("anvil server ready");
                        break;
                    }
                    await new Promise((resolve) => setTimeout(resolve, 100));
                }
            }
        }
        return new AnvilServer(options, anvil);
    }
    kill() {
        var _a;
        (_a = this._anvil) === null || _a === void 0 ? void 0 : _a.kill();
    }
    async waitUntilClosed() {
        return new Promise((resolve) => {
            this._anvil.once("close", resolve);
        });
    }
}
exports.AnvilServer = AnvilServer;
//# sourceMappingURL=anvil-server.js.map