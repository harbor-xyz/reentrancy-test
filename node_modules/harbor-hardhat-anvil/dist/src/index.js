"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ANVIL_NETWORK_NAME = void 0;
const debug_1 = __importDefault(require("debug"));
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const errors_1 = require("hardhat/internal/core/errors");
const errors_list_1 = require("hardhat/internal/core/errors-list");
const construction_1 = require("hardhat/internal/core/providers/construction");
const deploy_1 = require("./deploy");
const link_1 = require("./link");
const matchers_1 = require("./matchers");
require("./type-extensions");
const anvil_service_1 = require("./anvil-service");
exports.ANVIL_NETWORK_NAME = "anvil";
const log = (0, debug_1.default)("hardhat:plugin:anvil");
(0, config_1.extendEnvironment)((hre) => {
    // This mimics the `hardhat-waffle` plugin so that it works as replacement for
    // it this is currently necessary because the waffle plugin is bound to a network
    // with the name `hardhat`
    hre.waffle = (0, plugins_1.lazyObject)(() => {
        const { AnvilProviderAdapter } = require("./anvil-provider-adapter");
        const { hardhatCreateFixtureLoader } = require("./fixtures");
        const anvilWaffleProvider = new AnvilProviderAdapter(hre.network);
        return {
            provider: anvilWaffleProvider,
            deployContract: deploy_1.hardhatDeployContract.bind(undefined, hre),
            deployMockContract: (0, deploy_1.getDeployMockContract)(),
            solidity: require("./waffle-chai").waffleChai,
            createFixtureLoader: hardhatCreateFixtureLoader.bind(undefined, anvilWaffleProvider),
            loadFixture: hardhatCreateFixtureLoader(anvilWaffleProvider),
            link: (0, link_1.getLinkFunction)(),
        };
    });
    (0, matchers_1.initializeWaffleMatchers)(hre.config.paths.root);
});
(0, config_1.task)(task_names_1.TASK_TEST, async (_args, env, runSuper) => {
    return handlePluginTask(env, runSuper);
});
(0, config_1.task)(task_names_1.TASK_RUN, async (_args, env, runSuper) => {
    return handlePluginTask(env, runSuper);
});
(0, config_1.task)(task_names_1.TASK_NODE, "Starts Anvil RPC server").setAction(async (opts, { hardhatArguments, network }) => {
    // we throw if the user specified a network argument and it's not hardhat
    if (network.name !== exports.ANVIL_NETWORK_NAME &&
        hardhatArguments.network !== undefined) {
        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.JSONRPC_UNSUPPORTED_NETWORK);
    }
    const args = await anvil_service_1.AnvilService.getCheckedArgs(Object.assign(Object.assign(Object.assign({}, anvil_service_1.AnvilService.getDefaultAccountConfig()), opts), network.config));
    // launch anvil
    const server = await anvil_service_1.AnvilService.create(args, true);
    try {
        return server;
    }
    catch (error) {
        if (errors_1.HardhatError.isHardhatError(error)) {
            throw error;
        }
        if (error instanceof Error) {
            throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.JSONRPC_SERVER_ERROR, {
                error: error.message,
            }, error);
        }
        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
        throw error;
    }
});
(0, config_1.subtask)(task_names_1.TASK_NODE_GET_PROVIDER).setAction(async ({ forkBlockNumber: forkBlockNumberParam, forkUrl: forkUrlParam, }, { artifacts, config, network, userConfig }) => {
    var _a, _b, _c, _d, _e;
    let provider = network.provider;
    if (network.name !== exports.ANVIL_NETWORK_NAME) {
        const networkConfig = config.networks[exports.ANVIL_NETWORK_NAME];
        log(`Creating hardhat provider for JSON-RPC server`);
        provider = (0, construction_1.createProvider)(exports.ANVIL_NETWORK_NAME, networkConfig, config.paths, artifacts);
    }
    const anvilConfig = config.networks[exports.ANVIL_NETWORK_NAME];
    const forkUrlConfig = (_a = anvilConfig === null || anvilConfig === void 0 ? void 0 : anvilConfig.forking) === null || _a === void 0 ? void 0 : _a.url;
    const forkBlockNumberConfig = (_b = anvilConfig === null || anvilConfig === void 0 ? void 0 : anvilConfig.forking) === null || _b === void 0 ? void 0 : _b.blockNumber;
    const forkUrl = forkUrlParam !== null && forkUrlParam !== void 0 ? forkUrlParam : forkUrlConfig;
    const forkBlockNumber = forkBlockNumberParam !== null && forkBlockNumberParam !== void 0 ? forkBlockNumberParam : forkBlockNumberConfig;
    // we throw an error if the user specified a forkBlockNumber but not a
    // forkUrl
    if (forkBlockNumber !== undefined && forkUrl === undefined) {
        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.NODE_FORK_BLOCK_NUMBER_WITHOUT_URL);
    }
    // if the url or the block is different to the one in the configuration,
    // we use hardhat_reset to set the fork
    if (forkUrl !== forkUrlConfig ||
        forkBlockNumber !== forkBlockNumberConfig) {
        await provider.request({
            method: "anvil_reset",
            params: [
                {
                    forking: {
                        jsonRpcUrl: forkUrl,
                        blockNumber: forkBlockNumber,
                    },
                },
            ],
        });
    }
    const anvilUserConfig = (_d = (_c = userConfig.networks) === null || _c === void 0 ? void 0 : _c[exports.ANVIL_NETWORK_NAME]) !== null && _d !== void 0 ? _d : {};
    // enable logging
    await provider.request({
        method: "anvil_setLoggingEnabled",
        params: [(_e = anvilUserConfig === null || anvilUserConfig === void 0 ? void 0 : anvilUserConfig.loggingEnabled) !== null && _e !== void 0 ? _e : true],
    });
    return provider;
});
(0, config_1.extendConfig)((resolvedConfig, config) => {
    const defaultOptions = anvil_service_1.AnvilService.getDefaultAccountConfig();
    if (config.networks && config.networks.anvil) {
        const customOptions = config.networks.anvil;
        resolvedConfig.networks.anvil = Object.assign(Object.assign({}, defaultOptions), customOptions);
    }
    else {
        resolvedConfig.networks.anvil = defaultOptions;
    }
    // make compatible with the hardhat accounts object used by the waffleprovider
    resolvedConfig.networks.anvil.accounts = {
        mnemonic: resolvedConfig.networks.anvil.mnemonic,
        path: resolvedConfig.networks.anvil.hdPath,
        initialIndex: 0,
        count: resolvedConfig.networks.anvil.totalAccounts,
        passphrase: "",
    };
});
async function handlePluginTask(env, runSuper) {
    if (env.network.name !== "anvil") {
        return runSuper();
    }
    log("Starting Anvil");
    const options = env.network.config;
    const anvilService = await anvil_service_1.AnvilService.create(options);
    let ret;
    try {
        ret = await runSuper();
    }
    catch (error) {
        log("Stopping Anvil after error");
        anvilService.stopServer();
        throw error;
    }
    log("Stopping Anvil");
    anvilService.stopServer();
    return ret;
}
//# sourceMappingURL=index.js.map